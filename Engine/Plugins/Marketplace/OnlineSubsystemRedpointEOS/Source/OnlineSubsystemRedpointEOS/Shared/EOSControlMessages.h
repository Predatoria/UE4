// Copyright June Rhodes. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "Engine/ControlChannel.h"
#include "OnlineSubsystemRedpointEOS/Shared/EOSCommon.h"

#define EOS_CONTROL_CHANNEL_MESSAGE_MIN 40
#define EOS_CONTROL_CHANNEL_MESSAGE_MAX 51

// ----- Connection level messages -----

// Dedicated server has received the NMT_Hello message, and is requesting the client's certificate for the
// connection.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_RequestClientEphemeralKey,
    40,
    FString /* Server connection public key */,
    FString /* Signature of server connection public key, signed by dedicated server signing key */
);

// Client is sending back it's ephemeral public key.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_DeliverClientEphemeralKey,
    41,
    FString /* The packet data as generated by libhydrogen */
);

// Server has generated an AES symmetric key for the rest of the connection, and is handing it back
// to the client encrypted.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_SymmetricKeyExchange,
    42,
    FString /* The AES symmetric key encrypted with the client's public key to encrypt the rest of the session */
);

// Client has received the AES symmetric key and is enabling encryption.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_EnableEncryption,
    51
);

// ----- Login/beacon level messages -----

// The server is requesting the client's external platform credentials to verify their login. This control message can
// only be safely transferred over an encrypted connection.
DEFINE_CONTROL_CHANNEL_MESSAGE(EOS_RequestClientToken, 43, FUniqueNetIdRepl /* Target User ID */);

// The client is delivering their token to the trusted dedicated server so it can authenticate them against the EOS
// backend. Trusted dedicated servers will call EOS_Connect_Login with these credentials, and may use them to e.g. read
// and write data to PDS on the player's behalf.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_DeliverClientToken,
    44,
    FUniqueNetIdRepl /* Target User ID */,
    FString /* Client Token Type */,
    FString /* Client Display Name */,
    FString /* Client Token */);

#if EOS_VERSION_AT_LEAST(1, 12, 0)

// We are asking the client to prove that they're allowed to run as an unprotected client, if they can do so.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_RequestTrustedClientProof,
    45,
    FUniqueNetIdRepl /* Target User ID */,
    FString /* EncodedNonce */);

// The client is responding with either the proof that they can run unprotected, or that they need to run protected.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_DeliverTrustedClientProof,
    46,
    FUniqueNetIdRepl /* Target User ID */,
    bool /* bCanProvideProof */,
    FString /* EncodedProof */,
    FString /* PlatformString */);

// The client or server is sending EAC anti-cheat data to the other.
//
// NOTE: We should probably optimize this data format, since the repls might be big if EAC sends lots of network
// messages. For client-server layouts it's fairly straightforward, we'd just need a connection ID for the server to
// distinguish which client it's sending messages to (this would be negotiated during connect per logged in
// FUniqueNetIdRepl). It's trickier for peer-to-peer (listen servers), because we need the EOS ID when sending and
// receiving messages. Also, all of this might be more complicated than it needs to be, since we're assuming the same
// control channel can have multiple NMT_Login requests for split-screen, but that might not hold true in practice.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_AntiCheatMessage,
    47,
    FUniqueNetIdRepl /* Source User ID */,
    FUniqueNetIdRepl /* Target User ID */,
    TArray<uint8> /* Anti Cheat Data */);

#endif

// The server is asking the client to write a stat on their behalf; this is a workaround for an EOS SDK bug.
DEFINE_CONTROL_CHANNEL_MESSAGE(EOS_WriteStat, 48, TArray<uint8> /* SerializedStats */);

// The server is requesting the client's ID token to verify their login. This control message can
// only be safely transferred over an encrypted connection.
DEFINE_CONTROL_CHANNEL_MESSAGE(EOS_RequestIdToken, 49, FUniqueNetIdRepl /* Target User ID */);

// The client is delivering their ID token to the trusted dedicated server so it can verify the token against the EOS
// backend.
DEFINE_CONTROL_CHANNEL_MESSAGE(
    EOS_DeliverIdToken,
    50,
    FUniqueNetIdRepl /* Target User ID */,
    FString /* Client Token */);