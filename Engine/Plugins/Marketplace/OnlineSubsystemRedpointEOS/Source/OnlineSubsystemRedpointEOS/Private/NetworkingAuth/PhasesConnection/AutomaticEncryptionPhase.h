// Copyright June Rhodes. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "OnlineSubsystemRedpointEOS/Private/NetworkingAuth/AuthConnectionPhase.h"
#include "OnlineSubsystemRedpointEOS/Private/NetworkingAuth/AuthConnectionPhaseContext.h"
#include "OnlineSubsystemRedpointEOS/Shared/EOSCommon.h"
#if !defined(EOS_AUTOMATIC_ENCRYPTION_UNAVAILABLE)
#include "AESGCMHandlerComponent.h"
#endif
#include "RedpointLibHydrogen.h"

#define AUTH_PHASE_AUTOMATIC_ENCRYPTION FName(TEXT("AutomaticEncryption"))

class IAutomaticEncryptionCommon : public IAuthConnectionPhase
{
public:
    virtual ~IAutomaticEncryptionCommon(){};

    static void RegisterRoutes(class UEOSControlChannel *ControlChannel);

    virtual void On_NMT_EOS_RequestClientEphemeralKey(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) = 0;
    virtual void On_NMT_EOS_DeliverClientEphemeralKey(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) = 0;
    virtual void On_NMT_EOS_SymmetricKeyExchange(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) = 0;
    virtual void On_NMT_EOS_EnableEncryption(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) = 0;
};

#if !defined(EOS_AUTOMATIC_ENCRYPTION_UNAVAILABLE)

class FAutomaticEncryptionPhase : public IAutomaticEncryptionCommon
{
private:
    // Connection key/pair. Created by the server, and used for the N variant exchange.
    hydro_kx_keypair server_connection_unique_kp;

    // Client session keys. Only used on the client.
    hydro_kx_session_keypair client_session_kp;

    // Server session keys. Only used on the server.
    hydro_kx_session_keypair server_session_kp;

    // AES GCM symmetric key. Generated by server and securely passed to client.
    uint8_t AESGCMKey[FAESGCMHandlerComponent::KeySizeInBytes];

public:
    FAutomaticEncryptionPhase();
    virtual ~FAutomaticEncryptionPhase(){};

    virtual FName GetName() const override
    {
        return AUTH_PHASE_AUTOMATIC_ENCRYPTION;
    }

    virtual void Start(const TSharedRef<FAuthConnectionPhaseContext> &Context) override;

private:
    virtual void On_NMT_EOS_RequestClientEphemeralKey(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) override;
    virtual void On_NMT_EOS_DeliverClientEphemeralKey(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) override;
    virtual void On_NMT_EOS_SymmetricKeyExchange(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) override;
    virtual void On_NMT_EOS_EnableEncryption(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) override;
};

#else

class FUnavailableAutomaticEncryptionPhase : public IAutomaticEncryptionCommon
{
public:
    virtual ~FUnavailableAutomaticEncryptionPhase(){};

    virtual FName GetName() const override
    {
        return AUTH_PHASE_AUTOMATIC_ENCRYPTION;
    }

    virtual void Start(const TSharedRef<FAuthConnectionPhaseContext> &Context) override;

private:
    virtual void On_NMT_EOS_RequestClientEphemeralKey(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) override;
    virtual void On_NMT_EOS_DeliverClientEphemeralKey(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) override;
    virtual void On_NMT_EOS_SymmetricKeyExchange(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) override;
    virtual void On_NMT_EOS_EnableEncryption(
        const TSharedRef<FAuthConnectionPhaseContext> &Context,
        FInBunch &Bunch) override;
};

#endif // #if !defined(EOS_AUTOMATIC_ENCRYPTION_UNAVAILABLE)