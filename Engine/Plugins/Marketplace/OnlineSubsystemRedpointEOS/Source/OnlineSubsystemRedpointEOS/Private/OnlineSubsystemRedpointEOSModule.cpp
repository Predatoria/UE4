// Copyright June Rhodes. All Rights Reserved.

#include "OnlineSubsystemRedpointEOS/Public/OnlineSubsystemRedpointEOSModule.h"

#include "Containers/Ticker.h"
#include "Interfaces/OnlineIdentityInterface.h"
#include "Misc/CommandLine.h"
#include "Misc/ConfigCacheIni.h"
#include "OnlineSubsystemRedpointEOS/Private/NullOSS/OnlineSubsystemRedpointNull.h"
#include "OnlineSubsystemRedpointEOS/Shared/Authentication/AuthenticationGraphRegistry.h"
#include "OnlineSubsystemRedpointEOS/Shared/CompatHelpers.h"
#include "OnlineSubsystemRedpointEOS/Shared/EOSCommon.h"
#include "OnlineSubsystemRedpointEOS/Shared/EOSConfig.h"
#include "OnlineSubsystemRedpointEOS/Shared/EOSLifecycleManager.h"
#include "OnlineSubsystemRedpointEOS/Shared/EOSRuntimePlatform.h"
#include "OnlineSubsystemRedpointEOS/Shared/EpicGames/OnlineSubsystemRedpointEASFactory.h"
#include "OnlineSubsystemRedpointEOS/Shared/OnlineSubsystemRedpointEOS.h"
#include "OnlineSubsystemUtils.h"
#if WITH_GAMEPLAY_DEBUGGER
#include "GameplayDebugger.h"
#include "GameplayDebugger/GameplayDebuggerCategory_P2PConnections.h"
#endif // WITH_GAMEPLAY_DEBUGGER

#if PLATFORM_WINDOWS

#include "Windows/AllowWindowsPlatformTypes.h"

#include <libloaderapi.h>

#include "Windows/HideWindowsPlatformTypes.h"

#endif

EOS_ENABLE_STRICT_WARNINGS

#define LOCTEXT_NAMESPACE "FOnlineSubsystemRedpointEOSModule"

#if !defined(EOS_SDK_VERSION)
#define EOS_SDK_VERSION "NotSet"
#endif

#if WITH_EDITOR
static std::function<void(int32_t, const FString &, const FString &)> *RedpointEOSEditorLogHandler = nullptr;
static std::function<void(const FString &, const FString &)> *RedpointEOSEditorCustomSignalHandler = nullptr;
#endif

void EOSHandleLog(const EOS_LogMessage *Message)
{
    if (Message == nullptr)
    {
        return;
    }

    EOS_ELogLevel EOSMsgLevel = Message->Level;
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogEOSEcom") &&
        Message->Level == EOS_ELogLevel::EOS_LOG_Warning &&
        FString(ANSI_TO_TCHAR(Message->Message)).Contains(TEXT("EOS_NotConfigured")))
    {
        // This warning about the purchase flow not being available due to the overlay is just annoying and
        // not relevant for most games. Prevent it from generating a warning in tests by pushing it down
        // to info level.
        EOSMsgLevel = EOS_ELogLevel::EOS_LOG_Info;
    }
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogEOSConnect") &&
        Message->Level == EOS_ELogLevel::EOS_LOG_Warning &&
        FString(ANSI_TO_TCHAR(Message->Message)).Contains(TEXT("EOS_UnrecognizedResponse")))
    {
        // This warning is generated by a known bug where EOS returns EOS_UnrecognizedResponse when querying
        // for account information on device ID users. Prevent it from generating a warning in tests by
        // pushing it down to info level.
        EOSMsgLevel = EOS_ELogLevel::EOS_LOG_Info;
    }
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogEOSConnect") &&
        Message->Level == EOS_ELogLevel::EOS_LOG_Error &&
        FString(ANSI_TO_TCHAR(Message->Message))
            .Contains(TEXT("DeviceId access credentials not found on the local device.")))
    {
        // This error is generated when we try to sign in with device ID credentials for the first time, and the
        // credentials don't yet exist. It's not actually an error since the Authentication Graph will recognise
        // this result and automatically create the device ID credentials as needed. Prevent it from causing test
        // failures by pushing it down to info level.
        EOSMsgLevel = EOS_ELogLevel::EOS_LOG_Info;
    }
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogEOS") &&
        Message->Level == EOS_ELogLevel::EOS_LOG_Warning &&
        FString(ANSI_TO_TCHAR(Message->Message)).Contains(TEXT("errors.com.epicgames.eos.auth.user_not_found")))
    {
        // This warning is generated when an EOS user is not found, usually when signing in for the first time. Reduce
        // this to an informational message.
        EOSMsgLevel = EOS_ELogLevel::EOS_LOG_Info;
    }
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogEOSLobby") &&
        Message->Level == EOS_ELogLevel::EOS_LOG_Error &&
        FString(ANSI_TO_TCHAR(Message->Message))
            .Contains(
                TEXT("Invalid parameter EOS_Lobby_RejectInviteOptions.LocalUserId reason: cannot be null or empty")))
    {
        // Refer to FOnlinePartySystemEOS::RejectInvitation as to why this error can occur in situations where it's
        // safe to ignore it (allowing this error to propagate causes unnecessary unit tests failures).
        EOSMsgLevel = EOS_ELogLevel::EOS_LOG_Info;
    }
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogFileManager") &&
        Message->Level == EOS_ELogLevel::EOS_LOG_Error &&
        FString(ANSI_TO_TCHAR(Message->Message)).StartsWith(TEXT("Error moving file")))
    {
        // This non-critical error occurs on some platforms (where the EOS SDK does not seem to close file handles
        // properly). It's not a critical error in all cases, and the original operation can return
        // EOS_EResult::EOS_Success, but having this emit at error level causes the unit test to fail (even though
        // again, the operation succeeded). Downgrade it to a warning, since we check the EOS_EResult anyway.
        EOSMsgLevel = EOS_ELogLevel::EOS_LOG_Warning;
    }
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogEOSRateLimiter") &&
        Message->Level == EOS_ELogLevel::EOS_LOG_Warning &&
        FString(ANSI_TO_TCHAR(Message->Message))
            .Contains(TEXT("Falling back to the configuration of service level limits.")))
    {
        // These warnings confuse developers and they're never important. Lower this to very verbose.
        EOSMsgLevel = EOS_ELogLevel::EOS_LOG_VeryVerbose;
    }
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogEOSRTC") &&
        Message->Level == EOS_ELogLevel::EOS_LOG_Error &&
        FString(ANSI_TO_TCHAR(Message->Message))
            .Contains(TEXT("Attempted to call EOS_RTC_LeaveRoom on an internally managed room.")))
    {
        // The EOS SDK incorrectly logs this error when joining an RTC-enabled lobby. It's not an actionable message by
        // the user (or by the plugin implementation). Hide it entirely.
        EOSMsgLevel = EOS_ELogLevel::EOS_LOG_VeryVerbose;
    }
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogEOSAnalytics") &&
        (Message->Level == EOS_ELogLevel::EOS_LOG_Verbose || Message->Level == EOS_ELogLevel::EOS_LOG_Warning))
    {
        // These logs are extremely spammy when the EOS overlay is active. Just
        // hide them because they're not even useful for debugging.
        EOSMsgLevel = EOS_ELogLevel::EOS_LOG_VeryVerbose;
    }
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogEOSAuth") &&
        Message->Level == EOS_ELogLevel::EOS_LOG_Warning &&
        (FString(ANSI_TO_TCHAR(Message->Message))
             .Contains(TEXT("FAccountUtil::GetAsEpicAccount - Epic Account is Empty")) ||
         FString(ANSI_TO_TCHAR(Message->Message))
             .Contains(TEXT("FAccountPortalBrowserManager::Init: Failed to register overlay: EOS_NotConfigured"))))
    {
        // These are internal EOS SDK 1.15 warnings and aren't actionable by the developer.
        EOSMsgLevel = EOS_ELogLevel::EOS_LOG_VeryVerbose;
    }
#if PLATFORM_WINDOWS
    if (FString(ANSI_TO_TCHAR(Message->Category)) == TEXT("LogEOS") && Message->Level == EOS_ELogLevel::EOS_LOG_Error &&
        FString(ANSI_TO_TCHAR(Message->Message))
            .Contains(TEXT("Invalid input platform options. EOS_EResult: EOS_IncompatibleVersion")))
    {
        HMODULE LoadedEOSHandle = nullptr;
        if (GetModuleHandleEx(
                GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
                (LPCWSTR)&EOS_Platform_Create,
                &LoadedEOSHandle) != 0)
        {
            WCHAR ModulePath[4196];
            if (GetModuleFileName(LoadedEOSHandle, ModulePath, sizeof(ModulePath)) != 0)
            {
                UE_LOG(
                    LogEOS,
                    Error,
                    TEXT("Detected an incompatible version of the EOS SDK loaded from: %s. Please delete this file and "
                         "restart the editor or game."),
                    ModulePath);
            }
            else
            {
                UE_LOG(
                    LogEOS,
                    Warning,
                    TEXT("Unable to detect path to currently loaded EOS module while trying to provide path to "
                         "remove."));
            }
        }
        else
        {
            UE_LOG(
                LogEOS,
                Warning,
                TEXT("Unable to get handle to currently loaded EOS module while trying to provide path to remove."));
        }
    }
#endif

    switch (EOSMsgLevel)
    {
    case EOS_ELogLevel::EOS_LOG_Fatal:
    case EOS_ELogLevel::EOS_LOG_Error:
        UE_LOG(LogEOS, Error, TEXT("[%s] %s"), ANSI_TO_TCHAR(Message->Category), ANSI_TO_TCHAR(Message->Message));
        break;
    case EOS_ELogLevel::EOS_LOG_Warning:
        UE_LOG(LogEOS, Warning, TEXT("[%s] %s"), ANSI_TO_TCHAR(Message->Category), ANSI_TO_TCHAR(Message->Message));
        break;
    case EOS_ELogLevel::EOS_LOG_Info:
        UE_LOG(LogEOS, Log, TEXT("[%s] %s"), ANSI_TO_TCHAR(Message->Category), ANSI_TO_TCHAR(Message->Message));
        break;
    case EOS_ELogLevel::EOS_LOG_Verbose:
        UE_LOG(LogEOS, Verbose, TEXT("[%s] %s"), ANSI_TO_TCHAR(Message->Category), ANSI_TO_TCHAR(Message->Message));
        break;
    case EOS_ELogLevel::EOS_LOG_VeryVerbose:
        UE_LOG(LogEOS, VeryVerbose, TEXT("[%s] %s"), ANSI_TO_TCHAR(Message->Category), ANSI_TO_TCHAR(Message->Message));
        break;
    }

#if WITH_EDITOR
    if (RedpointEOSEditorLogHandler != nullptr)
    {
        (*RedpointEOSEditorLogHandler)(
            (int32_t)EOSMsgLevel,
            ANSI_TO_TCHAR(Message->Category),
            ANSI_TO_TCHAR(Message->Message));
    }
#endif
}

void *EOSHandleAllocate(size_t SizeInBytes, size_t Alignment)
{
    return FMemory::Malloc(SizeInBytes, Alignment);
}

void *EOSHandleReallocate(void *Pointer, size_t SizeInBytes, size_t Alignment)
{
    return FMemory::Realloc(Pointer, SizeInBytes, Alignment);
}

void EOSHandleRelease(void *Pointer)
{
    FMemory::Free(Pointer);
}

FOnlineSubsystemRedpointEOSModule::FOnlineSubsystemRedpointEOSModule()
    : IsRegisteredAsSubsystem(false)
    , bIsOperatingInNullMode(false)
    , EASSubsystemFactory(MakeShared<FOnlineSubsystemRedpointEASFactory>(this))
{
    this->RuntimePlatform = nullptr;
}

#if WITH_EDITOR
void FOnlineSubsystemRedpointEOSModule::SetLogHandler(
    std::function<void(int32_t, const FString &, const FString &)> EditorHandler)
{
    RedpointEOSEditorLogHandler =
        new std::function<void(int32_t, const FString &, const FString &)>(std::move(EditorHandler));
}

void FOnlineSubsystemRedpointEOSModule::SetCustomSignalHandler(
    std::function<void(const FString &, const FString &)> EditorHandler)
{
    RedpointEOSEditorCustomSignalHandler =
        new std::function<void(const FString &, const FString &)>(std::move(EditorHandler));
}

void FOnlineSubsystemRedpointEOSModule::SendCustomSignal(const FString &Context, const FString &SignalId)
{
    if (RedpointEOSEditorCustomSignalHandler != nullptr)
    {
        (*RedpointEOSEditorCustomSignalHandler)(Context, SignalId);
    }
}
#endif

void FOnlineSubsystemRedpointEOSModule::SetRuntimePlatform(const TSharedRef<IEOSRuntimePlatform> &InRuntimePlatform)
{
    this->RuntimePlatform = InRuntimePlatform;
}

#if !UE_BUILD_SHIPPING
FString FOnlineSubsystemRedpointEOSModule::GetPathToEASAutomatedTestingCredentials()
{
    checkf(
        this->RuntimePlatform.IsValid(),
        TEXT("GetPathToEASAutomatedTestingCredentials called before runtime platform set!"));
    return this->RuntimePlatform->GetPathToEASAutomatedTestingCredentials();
}
#endif

bool FOnlineSubsystemRedpointEOSModule::IsFreeEdition()
{
#if defined(EOS_IS_FREE_EDITION)
    return true;
#else
    return false;
#endif
}

bool FOnlineSubsystemRedpointEOSModule::HasInstance(FName InstanceName)
{
    return this->SubsystemInstances.Contains(InstanceName);
}

void FOnlineSubsystemRedpointEOSModule::StartupModule()
{
    if (IsRunningCommandlet() && !FParse::Param(FCommandLine::Get(), TEXT("alloweosincommandlet")))
    {
        // Prevent EOS from loading during cook.
        this->bIsOperatingInNullMode = true;
    }

#if defined(EOS_IS_FREE_EDITION)
    UE_LOG(
        LogEOS,
        Warning,
        TEXT("This application is using the Free Edition of the EOS Online Subsystem plugin. The developer of this "
             "application must not be earning more than $30,000 USD in a calendar year. See "
             "https://redpoint.games/eos-online-subsystem-free-eula/ for the EOS Online Subsystem Free Edition license "
             "agreement. If you have inquiries about this notice, you can email sales@redpoint.games."));
#endif

    FModuleManager &ModuleManager = FModuleManager::Get();
    if (ModuleManager.GetModule("OnlineSubsystemEOS") != nullptr || ModuleManager.GetModule("EOSShared") != nullptr)
    {
        UE_LOG(
            LogEOS,
            Error,
            TEXT("The Epic \"Online Subsystem EOS\" or \"EOS Shared\" plugin is enabled in this project. These "
                 "plugins conflict with the Redpoint EOS plugin, and they must be disabled from the Plugins window "
                 "(with the editor restarted afterwards) before the Redpoint EOS plugin will work."));
        return;
    }

#if defined(UE_5_0_OR_LATER)
    // Add the DefaultOnlineSubsystemRedpointEOS.ini file in the project's Config directory to the static
    // INI hierarchy of OnlineSubsystemRedpointEOS.ini at the correct location in the hierarchy.
    {
        FString Filename;
        FConfigCacheIni::LoadGlobalIniFile(Filename, TEXT("OnlineSubsystemRedpointEOS"));
        if (!Filename.IsEmpty())
        {
            FConfigFile *File = GConfig->Find(*Filename);
            if (File == nullptr)
            {
                File->AddDynamicLayerToHierarchy(FPaths::SourceConfigDir() / "DefaultOnlineSubsystemRedpointEOS.ini");
            }
            else
            {
                UE_LOG(
                    LogEOS,
                    Warning,
                    TEXT("Unable to apply project-specific overrides to OnlineSubsystemRedpointEOS.ini; custom net "
                         "driver settings will not be loaded."));
            }
        }
        else
        {
            UE_LOG(
                LogEOS,
                Warning,
                TEXT("Unable to determine config path for OnlineSubsystemRedpointEOS.ini; custom net "
                     "driver settings will not be loaded."));
        }
    }
#endif

    check(!this->EOSConfigInstance.IsValid());
    this->EOSConfigInstance = MakeShared<FEOSConfigIni>();

    if (this->EOSConfigInstance->GetProductName().IsEmpty() || this->EOSConfigInstance->GetProductVersion().IsEmpty())
    {
        this->bIsOperatingInNullMode = true;
    }

    if (this->bIsOperatingInNullMode)
    {
        UE_LOG(
            LogEOS,
            Verbose,
            TEXT("EOS module is operating in NULL mode, since this is either a commandlet or you haven't set the "
                 "product name and version in the Project Settings. Most functionality will be unavailable."));

        // Register the subsystem (this will generate null instances).

        auto OSS = ModuleManager.GetModule("OnlineSubsystem");
        if (OSS != nullptr)
        {
            ((FOnlineSubsystemModule *)OSS)->RegisterPlatformService(REDPOINT_EOS_SUBSYSTEM, this);
            this->IsRegisteredAsSubsystem = true;
        }
    }
    else
    {
        this->EOSConfigInstance->TryLoadDependentModules();

#if EOS_HAS_AUTHENTICATION
        // Register all the built-in authentication graphs. If you want to register your own authentication graphs, you
        // can do so inside your game's StartupModule.
        FAuthenticationGraphRegistry::RegisterDefaults();
#endif // #if EOS_HAS_AUTHENTICATION

        check(this->RuntimePlatform.IsValid());
        this->RuntimePlatform->Load();

        if (!this->RuntimePlatform->IsValid())
        {
            UE_LOG(LogEOS, Error, TEXT("EOS module skipping startup, because the EOS SDK could not be found."));
            return;
        }

        UE_LOG(LogEOS, Verbose, TEXT("Loaded EOS SDK version: %s."), ANSI_TO_TCHAR(EOS_GetVersion()));

        UE_LOG(LogEOS, Verbose, TEXT("EOS module starting up."));

        // Initialize the SDK.

        auto ProductName = StringCast<ANSICHAR>(*this->EOSConfigInstance->GetProductName());
        auto ProductVersion = StringCast<ANSICHAR>(*this->EOSConfigInstance->GetProductVersion());

        EOS_InitializeOptions SDKOptions = {};
        SDKOptions.ApiVersion = EOS_INITIALIZE_API_LATEST;
        SDKOptions.AllocateMemoryFunction = &EOSHandleAllocate;
        SDKOptions.ReallocateMemoryFunction = &EOSHandleReallocate;
        SDKOptions.ReleaseMemoryFunction = &EOSHandleRelease;
        SDKOptions.ProductName = ProductName.Get();
        SDKOptions.ProductVersion = ProductVersion.Get();
        SDKOptions.Reserved = nullptr;
        SDKOptions.SystemInitializeOptions = this->RuntimePlatform->GetSystemInitializeOptions();

        auto InitResult = EOS_Initialize(&SDKOptions);
        if (InitResult != EOS_EResult::EOS_Success)
        {
            UE_LOG(
                LogEOS,
                Error,
                TEXT("Unable to initialize EOS SDK (%s)."),
                ANSI_TO_TCHAR(EOS_EResult_ToString(InitResult)));
            if (FParse::Param(FCommandLine::Get(), TEXT("requireeos")))
            {
                checkf(
                    InitResult == EOS_EResult::EOS_Success,
                    TEXT("Unable to initialize EOS SDK (%s) and you have -REQUIREEOS on the command line."),
                    ANSI_TO_TCHAR(EOS_EResult_ToString(InitResult)))
            }
            return;
        }

        auto SetLogCallbackResult = EOS_Logging_SetCallback(&EOSHandleLog);
        if (SetLogCallbackResult != EOS_EResult::EOS_Success)
        {
            UE_LOG(LogEOS, Error, TEXT("Unable to set EOS SDK logging callback - expect log messages to be missing."));
        }
        EOS_Logging_SetLogLevel(EOS_ELogCategory::EOS_LC_ALL_CATEGORIES, EOS_ELogLevel::EOS_LOG_Verbose);

        // Register the subsystem.

        auto OSS = ModuleManager.GetModule("OnlineSubsystem");
        if (OSS != nullptr)
        {
            ((FOnlineSubsystemModule *)OSS)->RegisterPlatformService(REDPOINT_EOS_SUBSYSTEM, this);
#if EOS_HAS_AUTHENTICATION
            ((FOnlineSubsystemModule *)OSS)
                ->RegisterPlatformService(REDPOINT_EAS_SUBSYSTEM, &this->EASSubsystemFactory.Get());
#endif
            this->IsRegisteredAsSubsystem = true;
        }

#if EOS_VERSION_AT_LEAST(1, 15, 0)
        this->EOSLifecycleManager = MakeShared<FEOSLifecycleManager>(this, this->RuntimePlatform.ToSharedRef());
        this->EOSLifecycleManager->Init();
#endif

        UE_LOG(LogEOS, Verbose, TEXT("EOS module has finished starting up."));

#if WITH_GAMEPLAY_DEBUGGER
        FCoreDelegates::OnPostEngineInit.AddLambda([]() {
            IGameplayDebugger &GameplayDebuggerModule = IGameplayDebugger::Get();
            GameplayDebuggerModule.RegisterCategory(
                "P2PConnections",
                IGameplayDebugger::FOnGetCategory::CreateStatic(
                    &FGameplayDebuggerCategory_P2PConnections::MakeInstance),
                EGameplayDebuggerCategoryState::EnabledInGame,
                5);
            GameplayDebuggerModule.NotifyCategoriesChanged();
        });
#endif

#if WITH_EDITOR
        FWorldDelegates::OnPostWorldInitialization.AddLambda([](UWorld *World, const UWorld::InitializationValues IVS) {
            if (FParse::Param(FCommandLine::Get(), TEXT("eosauthorizer")))
            {
                UE_LOG(
                    LogEOS,
                    Verbose,
                    TEXT("Starting automatic editor-based authorization due to -eosauthorizer flag."));
                IOnlineSubsystem *OSS = Online::GetSubsystem(World, REDPOINT_EOS_SUBSYSTEM);
                if (OSS != nullptr)
                {
                    IOnlineIdentityPtr Identity = OSS->GetIdentityInterface();
                    Identity->AddOnLoginCompleteDelegate_Handle(
                        0,
                        FOnLoginCompleteDelegate::CreateLambda([](int32 LocalUserNum,
                                                                  bool bWasSuccessful,
                                                                  const FUniqueNetId &UserId,
                                                                  const FString &Error) {
                            if (!Error.IsEmpty() && !bWasSuccessful)
                            {
                                UE_LOG(LogEOS, Error, TEXT("The error from authentication was: %s"), *Error);
                            }

                            // Delaying this by one frame prevents a crash if the AutoLogin fails immediately (e.g. if
                            // the Free Edition user hasn't set a license key).
                            FUTicker::GetCoreTicker().AddTicker(
                                FTickerDelegate::CreateLambda([](float DeltaSeconds) {
                                    FGenericPlatformMisc::RequestExit(false);
                                    return false;
                                }),
                                0.0f);
                        }));
                    Identity->AutoLogin(0);
                }
            }
        });
#endif
    }
}

IOnlineSubsystemPtr FOnlineSubsystemRedpointEOSModule::CreateSubsystem(FName InstanceName)
{
#if WITH_EDITOR
    if (GIsAutomationTesting)
    {
        // Automation testing, but not through a unit test. This scenario is hit when testing the networking with
        // play-in-editor.
        if (this->AutomationTestingConfigOverride.IsValid())
        {
            return this->CreateSubsystem(InstanceName, this->AutomationTestingConfigOverride.ToSharedRef());
        }
    }
#endif

    return this->CreateSubsystem(InstanceName, this->EOSConfigInstance.ToSharedRef());
}

IOnlineSubsystemPtr FOnlineSubsystemRedpointEOSModule::CreateSubsystem(
    FName InstanceName,
    const TSharedRef<class FEOSConfig> &ConfigOverride)
{
    if (this->bIsOperatingInNullMode)
    {
        return MakeShared<FOnlineSubsystemRedpointNull, ESPMode::ThreadSafe>(InstanceName);
    }
    else
    {
        if (!this->RuntimePlatform->IsValid())
        {
            UE_LOG(
                LogEOS,
                Error,
                TEXT("The EOS SDK was not loaded at startup, so the online subsystem can not be created."));
            return nullptr;
        }

        check(!SubsystemInstances.Contains(InstanceName));

        auto Inst = MakeShared<FOnlineSubsystemEOS, ESPMode::ThreadSafe>(
            InstanceName,
            this,
            this->RuntimePlatform.ToSharedRef(),
            ConfigOverride);
        if (Inst->IsEnabled())
        {
            if (!Inst->Init())
            {
                UE_LOG(LogEOS, Warning, TEXT("Unable to init EOS online subsystem."));
                Inst->Shutdown();
                return nullptr;
            }
        }
        else
        {
            UE_LOG(LogEOS, Warning, TEXT("EOS online subsystem is not enabled."));
            Inst->Shutdown();
            return nullptr;
        }

        return Inst;
    }
}

void FOnlineSubsystemRedpointEOSModule::ShutdownModule()
{
    if (this->RuntimePlatform.IsValid() && this->RuntimePlatform->IsValid())
    {
        UE_LOG(LogEOS, Verbose, TEXT("EOS module shutting down."));

        TArray<class FOnlineSubsystemEOS *> Arr;
        for (auto Subsystem : this->SubsystemInstances)
        {
            Arr.Add(Subsystem.Value);
        }
        for (auto Subsystem : Arr)
        {
            bool bStillHasSubsystem = false;
            for (auto S : this->SubsystemInstances)
            {
                if (S.Value == Subsystem)
                {
                    bStillHasSubsystem = true;
                }
            }
            if (bStillHasSubsystem)
            {
                Subsystem->Shutdown();
            }
        }
        int NonShuttingDownInstances = 0;
        for (auto Subsystem : this->SubsystemInstances)
        {
            if (!Subsystem.Key.ToString().EndsWith(TEXT("_ShuttingDown")))
            {
                NonShuttingDownInstances++;
            }
        }
        ensureMsgf(
            NonShuttingDownInstances == 0,
            TEXT("Online subsystems did not cleanly shutdown on module shutdown. Ensure you are not holding references "
                 "to online subsystem objects longer than the lifetime of the online subsystem."));

        if (this->IsRegisteredAsSubsystem)
        {
            FModuleManager &ModuleManager = FModuleManager::Get();
            auto OSS = ModuleManager.GetModule("OnlineSubsystem");
            if (OSS != nullptr)
            {
                ((FOnlineSubsystemModule *)OSS)->UnregisterPlatformService(REDPOINT_EAS_SUBSYSTEM);
                ((FOnlineSubsystemModule *)OSS)->UnregisterPlatformService(REDPOINT_EOS_SUBSYSTEM);
                this->IsRegisteredAsSubsystem = false;
            }
        }

        EOS_Shutdown();

#if EOS_VERSION_AT_LEAST(1, 15, 0)
        this->EOSLifecycleManager->Shutdown();
        checkf(
            this->EOSLifecycleManager.IsUnique(),
            TEXT("Lifecycle manager must be unique; do not store shared pointers to it."));
        this->EOSLifecycleManager.Reset();
#endif

        UE_LOG(LogEOS, Verbose, TEXT("EOS module shutdown complete."));

        this->RuntimePlatform->Unload();
    }

    this->EOSConfigInstance.Reset();
}

#undef LOCTEXT_NAMESPACE

IMPLEMENT_MODULE(FOnlineSubsystemRedpointEOSModule, OnlineSubsystemRedpointEOS)

EOS_DISABLE_STRICT_WARNINGS
